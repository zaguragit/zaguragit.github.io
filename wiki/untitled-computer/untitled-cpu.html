<!doctype html>
<html lang=en>
  <head>
    <meta charset=utf-8>
    <meta http-equiv=Content-Security-Policy content="default-src 'none';img-src 'self';form-action 'self';base-uri 'self';style-src 'self';font-src 'self';">
    <meta name=copyright content=Zagura>
    <meta name=language content=en>
    <meta name=author content=Zagura>
    <meta name=web-author content=Zagura>
    <meta name=description content="Untitled CPU">
    <meta name=no-email-collection>
    <meta name=referrer content=no-referrer>
    <meta name=theme-color content=#2a2344>
    <meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
    <link rel=icon href=../../assets/me/icon.gif>
    <link rel=stylesheet href=../style.css>
    <title>Untitled CPU</title>
  </head>
  <body>
    <div id=page-container>
      <div id=sidebar>
        <header>
          <a rel=me href=/wiki>Zagura's Wiki</a>
        </header>
        <nav>
          <h3>Contents</h3>
          <ul>
            <li><a href=#>(Top)</a></li>
            <li><a href=#goals>Goals</a></li>
            <li><a href=#registers>Registers</a></li>
            <li><a href=#instructions>Instructions</a></li>
          </ul>
        </nav>
      </div>
      <main id=content>
        <section>
          <h1>Untitled CPU</h1>
          <div class=article-info>
            Last Updated: <time>Jan 5, 2024</time>
          </div>
          <p>
            A 32-bit RISC processor
          </p>
        </section>
        <section id=goals>
          <h2>Goals</h2>
          <p>
            The main goal of this processor is to be capable of running a usable os,
            but still be as simple &amp; energy-efficient as possible
          </p>
        </section>
        <section id=registers>
          <h2>Registers</h2>
          <table>
            <tr><th>Name(s)</th><th>Purpose</th></tr>
            <tr><td>0</td><td>immutable, always zero</td></tr>
            <tr><td>max</td><td>immutable, always max unsigned value (all 1s)</td></tr>
            <tr><td>ra</td><td>return address</td></tr>
            <tr><td>sp</td><td>stack pointer</td></tr>
            <tr><td>fp</td><td>frame pointer</td></tr>
            <tr><td>r0-4</td><td>work registers, calee must preserve</td></tr>
            <tr><td>a0-3</td><td>used for arguments, calee doesn't have to preserve</td></tr>
            <tr><td>v0-1</td><td>used for returned values, also v0 for operations
              (mul: gives high 32 bits | div: gives remainder | sum: gives carry)
            </td></tr>
          </table>
          <p>
            The program counter can't be accessed as a register
          </p>
        </section>
        <section id=instructions>
          <h2>Instructions</h2>
          <table>
            <tr><th>F</th><th>31-28</th><th>27-24</th><th>23-20</th><th>19</th><th>18</th><th>17-16</th><th>15-4</th><th>3-0</th><th>Comment</th></tr>
            <tr><td>J</td><td rowspan=5>op</td><td colspan=7>label28</td><td></td></tr>
            <tr><td>R</td><td rowspan=4>rd</td><td rowspan=4>rt</td><td colspan=3>rs</td><td></td><td>fn</td><td>12 free bits. not sure what to do with them yet, MIPS has a thing here, maybe ill steal it, but idk</td></td></tr>
            <tr><td>I</td><td colspan=5>imm</td><td></td></tr>
            <tr><td>L</td><td rowspan=2>bytes</td><td>sign</td><td colspan=3>imm</td><td>Special thing for a load instruction to specify whether to load 2 or 1 byte and how to extend it</td></tr>
            <tr><td>S</td><td colspan=4>imm</td><td>Special thing for a store instruction to specify whether to store 2 or 1 byte</td></tr>
          </table>
          <p>Instructions are picked to avoid redundancies, here are all the real ones (syntax sugar from the assembler not included):</p>
          <table>
            <tr><th>Opcode</th><th>Meaning</th><th>F</th><th>OP</th><th>FN</th></tr>
            <tr><td>add</td><td>adds ints, puts carry into v0</td><td>R</td><td>0000</td><td>0001</td></tr>
            <tr><td>sub</td><td>subtracts ints, puts borrow into v0</td><td>R</td><td>0000</td><td>0010</td></tr>
            <tr><td>mul</td><td>gives low 32 bits of multiplication, stores 32 high bits in v0</td><td>R</td><td>0000</td><td>0011</td></tr>
            <tr><td>div</td><td>gives quotient of signed division</td><td>R</td><td>0000</td><td>0100</td></tr>
            <tr><td>duv</td><td>gives quotient of unsigned division</td><td>R</td><td>0000</td><td>0101</td></tr>
            <tr><td>slz</td><td>shift left</td><td>R</td><td>0000</td><td>0110</td></tr>
            <tr><td>srz</td><td>shift right unsigned/logical (zero extend)</td><td>R</td><td>0000</td><td>0111</td></tr>
            <tr><td>srs</td><td>shift right arithmetic (sign extend)</td><td>R</td><td>0000</td><td>1000</td></tr>
            <tr><td>and</td><td>bitwise ANDs numbers</td><td>R</td><td>0000</td><td>1001</td></tr>
            <tr><td>or</td><td>bitwise ORs numbers</td><td>R</td><td>0000</td><td>1010</td></tr>
            <tr><td>xor</td><td>bitwise XORs numbers</td><td>R</td><td>0000</td><td>1011</td></tr>
            <tr><td>lts</td><td>gives 1 if left is less than right, otherwise 0 (signed)</td><td>R</td><td>0000</td><td>1100</td></tr>
            <tr><td>ltu</td><td>gives 1 if left is less than right, otherwise 0 (unsigned)</td><td>R</td><td>0000</td><td>1101</td></tr>
            <tr><td>add</td><td>same as non-immediate counterpart</td><td>I</td><td>0001</td><td>--</td></tr>
            <tr><td>slz</td><td>same as non-immediate counterpart</td><td>I</td><td>0010</td><td>--</td></tr>
            <tr><td>srz</td><td>same as non-immediate counterpart</td><td>I</td><td>0011</td><td>--</td></tr>
            <tr><td>and</td><td>same as non-immediate counterpart</td><td>I</td><td>0100</td><td>--</td></tr>
            <tr><td>or</td><td>same as non-immediate counterpart</td><td>I</td><td>0101</td><td>--</td></tr>
            <tr><td>jmp</td><td>goes to the instruction at label</td><td>J</td><td>0110</td><td>--</td></tr>
            <tr><td>jlk</td><td>store (PC + &lt;instruction width&gt;) in register ra, jump to label</td><td>J</td><td>0111</td><td>--</td></tr>
            <tr><td>jre</td><td>goes to the instruction at address in the register passed (might make it virtual if jlr is single-cycle)</td><td>R</td><td>0000</td><td>1110</td></tr>
            <tr><td>jlr</td><td>store (PC + &lt;instruction width&gt;) in register a, jump to address in register b</td><td>R</td><td>0000</td><td>1111</td></tr>
            <tr><td>beq</td><td>if a is equal to b, jump to label (represented as offset in memory)</td><td>I</td><td>1000</td><td>--</td></tr>
            <tr><td>bne</td><td>if a is not equal to b, jump to label (represented as offset in memory)</td><td>I</td><td>1001</td><td>--</td></tr>
            <tr><td>lod</td><td>load 4B at imm + .ptr as a 32-bit value into .a</td><td>I</td><td>1010</td><td>--</td></tr>
            <tr><td>sto</td><td>store value of .a starting at imm + .ptr</td><td>I</td><td>1011</td><td>--</td></tr>
            <tr><td>lod</td><td>load {b} bytes at address in .ptr as a 32-bit value into .a (if s = z zero-extends if s = s, sign-extends)</td><td>I</td><td>1100</td><td>--</td></tr>
            <tr><td>sto</td><td>store low {b} bytes of .a starting at address in .ptr</td><td>I</td><td>1101</td><td>--</td></tr>
            <tr><td>sys</td><td>runs the system call of the number in the register</td><td>I</td><td>1110</td><td>--</td></tr>
          </table>
          <p>
            I'm not sure what to do with the spare bits inside instructions that only
            use 1 register, or which of the 2/3 registers to use
          </p>
        </section>
      </main>
    </div>
  </body>
</html>
