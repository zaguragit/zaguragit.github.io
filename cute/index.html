<!doctype html>
<html lang=en>
  <head>
    <meta charset=utf-8>
    <meta http-equiv=Content-Security-Policy content="default-src 'none';img-src 'self';form-action 'self';base-uri 'self';style-src 'self';font-src 'self';">
    <meta name=copyright content=Zagura>
    <meta name=language content=en>
    <meta name=author content=Zagura>
    <meta name=web-author content=Zagura>
    <meta name=description content="A language">
    <meta name=no-email-collection>
    <meta name=referrer content=no-referrer>
    <meta name=theme-color content=#38244c>
    <meta name=color-scheme content=dark>
    <meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
    <link rel=icon href=../assets/gif/cute.gif>
    <link rel=stylesheet href=../style.css>
    <link rel=stylesheet href=style.css>
    <title>Cute</title>
  </head>
  <body>
    <div class=header>
      <a href="/">zagura on cyberspace</a>
      <div class=spacer></div>
      <nav>
        <a href=/about>/about</a>
        <a href=/dev>/dev</a>
        <a href=/art>/art</a>
        <a href=/lists>/lists</a>
        <a href=/resume>/resume</a>
      </nav>
    </div>
    <main>
      <center>
        <img src=../assets/gif/cute.gif height=128px class=pixelart>
        <h1>Cute</h1><br>
        <p>A multipurpose language aimed at simplicity, with a novel syntax (page under construction)</p>
      </center>
      <a href=https://github.com/cutelang class=gemini>Source</a>
      <h1>Syntax</h1>

      <h2>Intentions</h2>
      <p>
        My intentions with this language are to make the most optimal syntax, without limiting myself to familiarity.
        Also, the language should ideally strive towards cuteness, so short, friendly-looking keywords, concise syntax & no overly sharp/noisy symbols
      </p>

      <h2>List of reserved keywords</h2>
      <p>
        <code class=kw>using</code>, <code class=kw>module</code>, <code class=kw>extern</code>, <code class=kw>enum</code>,
        <code class=kw>class</code>, <code class=kw>impl</code>, <code class=kw>when</code>, <code class=kw>loop</code>,
        <code class=kw>break</code>, <code class=kw>return</code>, <code class=kw>mut</code>, <code class=kw>and</code>,
        <code class=kw>or</code>, <code class=kw>try</code>, <code class=kw>my</code>, <code class=kw>our</code>,
        <code class=kw>new</code>, <code class=kw>type</code><br>
        Also there's <code class=literal>yes</code> & <code class=literal>no</code>, but they're values & not just tokens
      </p>
      <h2>Comments</h2>
      <p>
        2 types of comments are supported, 
        the compiler completely ignores them
      </p>
      <p>
        <ul>
          <li>Single-line comments: <code class=comment>-- comment</code></li>
          <li>Multi-line comments: <code class=comment>--( comment )--</code></li>
        </ul>
      </p>

      <h2>Operators</h2>
      <p>
        <h3>Binary Mathematical Operators</h3>
        <p><pre>+   -   *   /   %  ^  &&  ||  ^|  &gt;&gt;  &lt;&lt;  &lt;&lt;&lt;  &gt;&gt;&gt;</pre></p>
        <p>
          <ul>
            <li><code>^&nbsp;</code>: means left to the power of right</li>
            <li><code>^|</code>: performs an xor operation</li>
            <li><code>+&nbsp;</code>: concatenates strings (if left is string, but right isn't, the compiler will search for a <code>to_string</code> method, to convert it), and also combines arrays & arrays with items</li>
          </ul>
        </p>
        <p>Bitwise operators are only allowed on types with explicit bit sizes</p>
        <h3>Unary Mathematical Operators</h3>
        <p>
          <ul>
            <li><code>~</code> : Flips bits, when used on booleans, basically does a not operation</li>
            <li><code>-</code> : Negates number</li>
            <li><code>+</code> : Absolute value</li>
          </ul>
        </p>
        <h3>Logical Operators</h3>
        <p>
          <pre><span class=kw>and  or</span></pre>
        </p>
        <p>
          Please note, <code>&&</code>/<code>||</code> is used for bit-wise operations,
          while <code class=kw>and</code>/<code class=kw>or</code> is for logical operations
          (which means that it short-circuits)
        </p>
        <h3>Comparison Operators</h3>
        <p>
          <pre>&gt;  &lt;  &gt;=  &lt;=  =  ~=  ==  ~==</pre>
        </p>
        <p>
          <ul>
            <li><code>=</code> : checks for equality</li>
            <li><code>==</code> : checks for identity</li>
          </ul> 
        </p>
        <h3>Mutability Operators</h3>
        <p>
          <ul>
            <li><code>&lt;-</code> : Assigns right to left and evaluates to right, so that assignment chains are possible</li>
            <li><code>*&nbsp;</code> : (unary) Get the value of the operand</li>
          </ul>
        </p>
        <p>This applies to the <code class=kw>mut</code> datatype, which is created using the <code class=kw>mut</code> unary operator</p>
        <h3>Operator precedence</h3>
        <p>
          <ul>
            <li>All unary operators</li>
            <li><code>^</code></li>
            <li><code>*  /</code></li>
            <li><code>+  -  %</code></li>
            <li><code>&lt;&lt;  &gt;&gt;  &lt;&lt;&lt;  &gt;&gt;&gt;</code></li>
            <li><code>&&  ||  ^|</code></li>
            <li><code>&lt;  &gt;  =  &gt;=  &lt;=  ~=  ==  ~==</code></li>
            <li><code class=kw>and  or</code></li>
            <li><code>&lt;-</code></li>
          </ul>
        </p>
        <p>The operators that can be overloaded are:</p>
        <p>
          <pre>+   -   *   /   %  ^  &&  ||  ^|  &gt;&gt;  &lt;&lt;  &lt;&lt;&lt;  &gt;&gt;&gt;  &lt;-  =  ~</pre>
        </p>
        <p>
          If the <code>=</code> is overloaded, <code>~=</code> can be used to get the inverse result<br>
          If one of the 2 expressions of <code>=</code> is, or might be, <code class=literal>()</code>,
          the program will first check that & if both sides aren't <code class=literal>()</code> they'll bet compared using the overloaded operator<br>
        </p>
        <p>Only the <code>&lt;-</code> operator chains from right to left</p>
      </p>
      <h2>Fields</h2>
      <p>AKA variables</p>
      <p>Fields are immutable, and have a very simple syntax:</p>
      <p><pre><span class=kw>my</span> field_name = field_value</pre></p>
      <p>Cute uses the <code class=kw>my</code> keyword for private or local fields & the <code class=kw>our</code> keyword for public ones</p>
      <p><pre><span class=kw>our</span> field_name = field_value</pre></p>
      <p>One can specify the type by adding <code>: <span class=type>type_name</span></code> after the value</p>
      <p>Here are some examples:</p>
      <p>
        <pre><span class=kw>my</span> a = <span class=literal>5</span>
<span class=kw>my</span> b = <span class=literal>5</span> : <span class=type>Int</span>
<span class=kw>my</span> c = <span class=literal>5</span> : <span class=type>Num</span>
<span class=kw>my</span> d = <span class=literal>0'6</span> : <span class=type>Num</span>
<span class=kw>my</span> e = <span class=literal>0'6</span> : <span class=type>ℚ</span>
<span class=kw>my</span> f = <span class=literal>1</span> : <span class=type>ℤ</span>
<span class=kw>my</span> g = <span class=literal>2'4</span> : [<span class=literal>0'0</span>...]
<span class=kw>my</span> h = <span class=literal>"blablabla"</span>
<span class=kw>my</span> i = <span class=literal>"blablabla"</span> : <span class=type>String</span></pre>    
      </p>
      <h2>Mutability</h2>
      <p>
        All fields are immutable,
        but Cute has a <code><span class=kw>mut</span> t</code> datatype,
        which allows to get & set its value,
        using the operators <code>&lt;-</code> (assignment) & <code>*</code> (unboxing)
      </p>
      <p>To understand it easier for people coming from C, it's like a pointer, but you can't do math with it, & it doesn't cause a segfault</p>
      <p>To create a mutable value, use the <code class=kw>mut</code> keyword with a value after it</p>
      <p>Example:</p>
      <p>
        <pre>
<span class=kw>my</span> a = <span class=kw>mut</span> <span class=literal>5</span>
<span class=comment>-- a is of type mut int</span>
<span class=kw>my</span> b = *a
<span class=comment>-- b is 5, of type int</span>
<span class=kw>my</span> c = a
<span class=comment>-- c is 5, of type mut int</span>
a &lt;- *a + <span class=literal>3</span>
<span class=comment>-- a is 8, c is 8, b is 5</span></pre>
      </p>
      <h2>Parentheses</h2>
      <p>The parentheses in cute aren't only for math, they also act as scoped code blocks</p>
      <p>A block evaluates to the common type of its return statements & its last statement/expression</p>
      <p>Using the <code class=kw>return</code> keyword will make the block evaluate to the value returned (or <code class=literal>()</code>, if nothing is returned), and jump out of the block</p>
      <h2>Branching</h2>
      <p>AKA If/Else</p>
      <p>This is the base syntax for branching:</p>
      <pre><span class=kw>my</span> thing = <span class=kw>when</span>
  | condition_a: <span class=fn>foo</span> ()
  | condition_b: <span class=fn>bar</span> ()
  | condition_c: <span class=fn>baz</span> ()
  |: <span class=fn>do_something_else</span> ()</pre>
      <p>The first <code>|</code> is optional, so that the one-liner syntax is cleaner</p>
      <pre>
<span class=kw>my</span> my_field_0 = <span class=kw>when</span>
  | condition_a: <span class=fn>foo</span> ()
  |: <span class=fn>bar</span> ()

<span class=kw>my</span> my_field_1 = <span class=kw>when</span> | condition_a: <span class=fn>foo</span> () |: <span class=fn>bar</span> ()

<span class=kw>my</span> my_field_2 = <span class=kw>when</span> condition_a: <span class=fn>foo</span> () |: <span class=fn>bar</span> ()

<span class=kw>when</span> condition_a <span class=kw>or</span> condition_b:
    <span class=fn>foo</span> ()

<span class=kw>when</span> condition_a <span class=kw>or</span> condition_b: (
    <span class=fn>bar</span> ()
    <span class=fn>baz</span> ()
)</pre>
      <h2>Loop</h2>
      <p>
        Using the <code class=kw>loop</code> keyword makes the next expression loop forever
        (unless the <code class=kw>break</code> keyword is used, in which case it will make the
        loop evaluate to the value returned & jump out of the loop)
      </p>
      <p>Examples:</p>
      <pre>
<span class=kw>my</span> i = <span class=kw>mut</span> <span class=literal>0</span>
<span class=kw>my</span> thing = <span class=kw>loop</span> (
    i <- *i + <span class=literal>1</span>
    <span class=fn>cmd::ln</span> (i)
    <span class=kw>when</span> i = <span class=literal>12</span>: <span class=kw>break</span> <span class=literal>3</span>
)
<span class=comment>-- thing is 3</span></pre>
      <p>Loops can use any expression, so this is also valid:</p>
      <p>
        <pre><span class=kw>loop</span> <span class=fn>do_something</span> ()</pre>
      </p>
      <h2>Break &amp; Return</h2>
      <p>
        Both <code>break</code> & <code>return</code> keywords act almost the same,
        except <code>return</code> jumps out of a code block, while <code>break</code> jumps out of a loop.
        If <code>return</code> is used inside a code block in a loop, it works like "continue" in C-like languages
      </p>
      <p>
        You can append <code>@label</code> to the keyword, to point to a specific loop/block (defaults to the closest one),
        the label name is the same as the field you assign the loop/block to, for example:
      </p>
      <p>
        <pre>
<span class=kw>my</span> my_loop = <span class=kw>loop</span> {
  <span class=kw>break</span><span class=literal>@my_loop</span>
}
<span class=kw>my</span> my_block = {
  <span class=kw>return</span><span class=literal>@my_block</span>
}</pre>
      </p>
      <p>You can also append an expression to make the loop/block evaluate to it:</p>
      <p>
        <pre>
<span class=kw>my</span> i = <span class=kw>mut</span> <span class=literal>0</span>
<span class=kw>my</span> thing = <span class=kw>loop</span> {
    i <- *i + <span class=literal>1</span>
    <span class=kw>when</span> i = <span class=literal>12</span>: <span class=kw>break</span><span class=literal>@thing 4</span>
}
<span class=comment>-- thing is 4</span></pre>
      </p>
      <h2>Functions & Lambdas</h2>
      <p>In Cute, functions are written as fields with lambda values</p>
      <p>A lambda is written as: <code>(x) -> expression</code> or <code>(p0: <span class=type>some_type</span> -> <span class=type>return_type</span>) -> expression</code></p>
      <p>The return type can't be omitted in global functions</p>
      <p>
        To add type arguments to the function put <code>a, b =></code> after the first paren,
        like so <code>(<span class=type>t</span> => p0: <span class=kw>mut</span> <span class=type>t</span> -> <span class=type>t</span>) -> *p0</code>
      </p>
      <p>Some examples:</p>
      <p>
        <pre>
<span class=kw>my</span> pow = (x: <span class=type>Int</span>, y: <span class=type>Int</span> -> <span class=type>Int</span>) -> x ^ y
<span class=kw>my</span> sum = (x, y) -> x + y
<span class=kw>my</span> div = (x: <span class=type>Int</span>, y: <span class=type>Int</span>) -> x / y
<span class=kw>my</span> do_stuff = (x: <span class=type>Int</span>, y: <span class=type>Int</span>) -> (
    <span class=fn>cmd::ln</span> (<span class=literal>"Hello World!"</span>)
)
<span class=kw>my</span> just_return = (<span class=type>t</span> => x: <span class=type>t</span> -> <span class=type>t</span>) -> x
<span class=kw>my</span> print_and_return = (<span class=type>t</span> => x: <span class=type>t</span> -> <span class=type>t</span> # <span class=literal>text::Textual</span> <span class=type>t</span>) -> {
    <span class=fn>cmd::ln</span> (t \ <span class=fn>to_string</span>)
    x
}</pre>
      </p>
      <p>You can call functions normally: <code><span class=fn>function_name</span> (arg0, arg1, some_param: arg2)</code></p>
      <p>Or with method/pipe first syntax: <code>arg0 \ <span class=fn>function_name</span> (arg1, some_param: arg2)</code></p>
      <p>Or even with simple pipe syntax: <code>arg0 \: <span class=fn>function_name</span></code> or <code>arg0 \: x -> (x + <span class=literal>4</span>) * x * <span class=literal>4</span></code></p>
      <p>To overload an operator, write it between braces as the field's name:</p>
      <p><pre><span class=kw>my</span> (<span class=fn>=</span>) = (a: <span class=type>V3</span>, b: <span class=type>V3</span> -> <span class=type>Bool</span>) -> a.x = b.x <span class=kw>and</span> a.y = b.y <span class=kw>and</span> a.z = b.z</pre></p>
      <h2>Types</h2>
      <p>
        There are 2 main, multipurpose numeric types: <code class=type>Int</code> & <code class=type>Num</code> (can also be written as <code class=type>ℤ</code> & <code class=type>ℚ</code>), which don't have an explicit size.<br>
        For specific bit size, use one of <code class=type>B8</code>, <code class=type>B16</code>, <code class=type>B32</code>, <code class=type>B64</code>
      </p>
      <p>
        <code class=type>Int</code> & <code class=type>Num</code> are the widest integer & decimal ranges<br>
        Smaller range types can be written as <code>[min..max]</code>, <code>[min...]</code>, or <code>[...max]</code>
      </p>
      <p><pre><span class=kw>my</span> a = <span class=literal>32'4</span> : [<span class=literal>5'0</span>..<span class=literal>50</span>]</pre></p>
      <p>Tuple types are written as <code>(</code> + params + <code>)</code></p>
      <p><pre>(x: <span class=type>ℚ</span>, y: <span class=type>ℚ</span>, z: <span class=type>ℚ</span>)</pre></p>
      <p>To declare a generic tuple, add the type params after the <code>(</code></p>
      <p>
        <pre>
<span class=kw>our</span> <span class=type>Container</span> = <span class=kw>new type</span> ( <span class=type>t</span> =>
    value: <span class=type>t</span>,
)</pre>
      </p>
      <p>To express an array type, use the <code>[]<span class=type>t</span></code> syntax, where you can optionally add a range between the brackets</p>
      <p><code class=type>Never</code> is the type used for operations that never return a value, like <code class=kw>break</code> & <code class=kw>return</code></p>
      <p><code class=type>Any</code> is the parent type of everything</p>
      <p><code class=type>Bool</code> is the boolean type, duh, it accepts the values <code class=literal>yes</code> & <code class=literal>no</code></p>
      <p><code class=type>String</code> is an alias to an array of <code class=type>B8</code></p>
      <p><code class=literal>()</code> is both the nil value, and the type, and it replaces "Unit" or "void"</p>
      <p><code><span class=kw>mut</span> <span class=type>t</span></code> is a mutable reference to <code class=type>t</code></p>
      <h3>Declarations</h3>
      <p>
        Like functions, types are declared by being assigned to a field<br>
        Use the <code class=kw>type</code> keyword before writing the type notation<br>
        Use the <code class=kw>new</code> keyword to make a new type, otherwise it will make an alias<br>
      </p>
      <p>
        <pre>
<span class=kw>our</span> <span class=type>V3</span> = <span class=kw>new type</span> (
    x: <span class=type>ℚ</span>,
    y: <span class=type>ℚ</span>,
    z: <span class=type>ℚ</span>,
)</pre>
      </p>
      <p>All newtypes have a constructor with a single param of it's parent:</p>
      <p><pre><span class=kw>my</span> position = <span class=type>V3</span> ((<span class=literal>3</span>, <span class=literal>6</span>, <span class=literal>2</span>))</pre></p>
      <h3>Unions</h3>
      <p>Types can be combined into union types using the <code>|</code> operator</p>
      <h3>Optional & ()</h3>
      <p>
        Cute has first class optional types, like Kotlin.
        They're written as <code class=type>?type_name</code>, which is a shorthand for <code class=type>type_name|()</code>.
        <code class=literal>()</code> has only 1 possible value, <code class=literal>()</code>, yes, they're both written the same way.
        Also, there's no Void or Unit type, <code class=literal>()</code> fully replaces it
      </p>
      <h3>Generics</h3>
      <p>Generic types are written as <code><span class=type>type_name</span> (<span class=type>some_type</span>, <span class=type>some_other_type</span>)</code></p>
      <p>
        If only 1 arg is needed, the <code class=literal>()</code> can be skipped, for example:
        <code><span class=kw>mut</span> (<span class=type>Box</span> (<span class=kw>mut</span> (<span class=type>Int</span>)))</code>
        can be written as <code><span class=kw>mut</span> <span class=type>Box</span> <span class=kw>mut</span> <span class=type>Int</span></code>
      </p>
      <p>Some examples:</p>
      <p>
        <pre>
<span class=kw>my</span> get_at_index = (array: []<span class=type>ℤ</span>, index: <span class=type>ℤ</span>) -> array[index]
<span class=kw>my</span> set_to_0 = (x: <span class=kw>mut</span> <span class=type>ℤ</span>) -> (x &lt;- <span class=literal>0</span>)
<span class=kw>my</span> a = <span class=kw>mut</span> <span class=literal>4</span> : <span class=kw>mut</span> <span class=type>ℤ</span></pre>
      </p>
      <h2>Tuples</h2>
      <p>Tuples can have names or unnamed fields</p>
      ```swift
      let v3 = { x: 3, y: 65, z: 12 }
      let v3 = { 3, 65, 12 }
      ```
      If enough information is available for type inference, the tuple can be converted to its descendant type
      ```swift
      let position = { 3, 6, 2 } : v3
      ```
      
      ### Field access
      
      Tuple fields are accessed like in Kotlin: `position.y`
      
      If the value (in this example `position`) is of an optional type, `position?.y` (nil safety) must be used, otherwise, the compiler will give you an error
      
      If the fields aren't named explicitly, the position of the field in the tuple is used as the name `my_vector.0`
      
      
      ## Nil Safety
      
      The nil safety operator `?` can only be used inside a `try` expression
      ```rust
      let a = try my_vector?.x
      ```
      if the operand is null, the entire try expression will evaluate to null, otherwise it will continue
      
      
      ## Namespaces
      
      You can assign a namespace to a file by having a namespace declaration, like so: `namespace path::to::stuff`
      
      You can also import stuff from a namespace like so: `using path::to::stuff`
      
      If a file has no namespace, it's an entry file, and it's contents are treated kinda like a main function (probably won't actually go with that)
      
      
      ## Metadata
      
      Metadata can be provided after the `let` keyword for fields & change their behaviour using attributes
      
      The syntax of metadata is `[` + comma-separated attributes + `]`
      
      The syntax of an attribute is the same as of a function call, except the parens are optional if there's no more than 1 argument & it's not named
      
      These are the builtin annotations:
      - `inline` tells the compiler that this function must be inlined
      - `entry` tells what function to execute on startup
      - `builtin (name: string)` can only be applied to `extern` fields, maps the function/field to an operation that doesn't have it's own syntax, like conversion between primitive numeric types
      - `c (name: string)` low-level field metadata (currently just the linking name)
      
      Example
      ```rust
      let [
          inline,
          c (name: "sum"),
          operator "plus",
          deprecated (
              since: "0.2",
              reason: "just felt like it",
          ),
      ]
      my_function = (x: int, y: int -> int) -> x + y
      ```
      
      
      ## Traits
      
      Traits (aka type classes) are defined as `trait` + generic type names + `[` + required fields + `]`
      Example
      ```lua
      let describable = trait s [
          to_string: (s -> string)
      ]
      ```
      
      Trait implementations (aka type class instances) are written as `impl` + trait name + `(` + comma-separated types `)` + `[` + required fields + `]`
      Example:
      ```lua
      impl text::describable (int) [
          let to_string = (i: int -> string) -> i \ to_string (10)
      ]
      -- Now you can do 12 \ to_string ()
      ```
      When implementing a trait, return types can be omitted, since they're explicitly stated in the trait declaration
      ```lua
      impl text::describable (int) [
          let to_string = (i: int) -> i \ to_string (10)
      ]
      ```
      To use a trait in a function, use the `#` after the type params, like so:
      ```lua
      let println = (t # describable t => x: t) (
          println (x \ to_string ())
      )
      ```
      
      
      ## Literals
      
      Floats are written in base 10, with a `'` between the integral & decimal parts: `3'5`, `2'00001`, `5'0`, `0'1`
      Integers are written in base 10 by default: `10`, `42`; but can be written in any base less than 36, by prepending them by the base number & a colon: `16:00ff88`, `8:1244`
      
      Int literals are automatically converted into floats if a float is needed instead
      
      Booleans use the `yes` & `no` keywords
      
      `nil` is `nil`
      
      Strings are written using double quotes `"`, with the typical character escapes: `\n, \t, \r, \\, \", \0`, + unicode character escapes: `\u1234`
      Example: `"Hello World! \n"`
      
      ### Arrays
      There are 2 ways to write an array literal:
      Just items: `[` + comma-separated items +  `]`
      ```lua
      [a, b, c, d]
      ```
      Dynamically allocated: `[` + amount of items + `|` + initializer + `]`
      ```lua
      [12 | x -> x * 2] -- an array of 12 items, each being the double of its index
      ```
      
      # Undecided Areas
      
      ## Shadowed fields
      Might use the `@label` syntax from `break`/`return` to specify from which block/scope the field is


      <div>
        <pre>
<span class=comment>-- you can assign types to fields, if you</span>
<span class=comment>-- use the type keyword before the type syntax</span>
<span class=kw>my</span> <span class=type>AliasToTuple</span> = <span class=kw>type</span> (
  a: <span class=type>ℤ</span>,
  b: <span class=type>ℤ</span>,
)
<span class=comment>-- btw, this is how you create a tuple</span>
<span class=kw>my</span> stuff = (<span class=literal>"hi"</span>, <span class=literal>6</span>, <span class=literal>2'2</span>)

<span class=comment>-- you can create new types by placing</span>
<span class=comment>-- the new keyword before the type expression</span>
<span class=kw>my</span> <span class=type>V3</span> = <span class=kw>new</span> <span class=kw>type</span> (
  x: <span class=type>ℚ</span>,
  y: <span class=type>ℚ</span>,
  z: <span class=type>ℚ</span>,
)
<span class=comment>-- this is how you create a value of type V3,</span>
<span class=comment>-- basically put the underlying type in a</span>
<span class=comment>-- function with the name of the type</span>
<span class=kw>my</span> vector = V3 ((<span class=literal>4</span>, <span class=literal>2</span>, <span class=literal>2</span>))

<span class=comment>-- the underlying type is still assignable to the descendant & viceversa</span>
<span class=comment>-- but descendants aren't assignable to each other</span>
<span class=kw>my</span> vector = (<span class=literal>4</span>, <span class=literal>2</span>, <span class=literal>2</span>) : V3

<span class=kw>my</span> <span class=fn>function</span> = (q: <span class=type>V3</span>) -> q.y
        </pre>
    </main>
  </body>
</html>